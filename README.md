# epamJavaTest
10.11.2015 JavaTest
Крутихин Михаил Владимирович

1.Абстрактный класс - класс, в котором все методы не определены.(состоят только из объявления и не имеют тела).
Интерфейсы – объекты, которые напоминают класс, но могут содержать только константы, сигнатуры методов и вложенные типы. (в них нет описания методов.)
Отичия:
Интерфейс может только описывать константы и методы, но не реализовывать их. Все методы интерфейса по-умолчанию являются публичными (public) и абстрактными (abstract), а поля - public static final. 
В Java класс может наследоваться (реализовывать) от многих интерфейсов, но только от одного абстрактного класса. 
С абстрактными классами теряется индивидуальность класса, наследующего его; с интерфейсами расширяется функциональность каждого класса.

2. Сборщик мусора – это процесс, который запускается периодически и освобождает память, использованную объектами, которые больше не нужны.(Т.е. объекты на которые больше нет ссылок.) JVM обычно запускает сборщик мусора при низком уровне свободной памяти. 
Можно запросить запуск сборщика мусора, но нельзя вызвать его насильно. Для запроса запуска сборщика мусора можно использовать методы :
System.gc()
Runtime.getRuntime().gc()

3. При присваивание разных типов объектов друг другу.

4. Конструктор - это схожая  c методом структура, назначение которой состоит в создании экземпляра класса. Нужен для автоматической инициализации переменых. Имя конструктора совпадает с именем класса, включая регистр, а по синтаксису конструктор похож на метод без возвращаемого значения.
Отличия от методов:
1)	конструктор ничего не возвращает.
2)	Конструктор вызывается в месте выполнения оператора new.
3)	Конструктор имеется в любом классе. Даже если он не написан, компилятор Java сам создаст конструктор по умолчанию.
4)	Конструктор нельзя наследовать или переопределить в подклассе

5. Да, можно. В классе может быть несколько конструкторов (перегруженные конструкторы). В этом случает один конструктор можно вызвать из другого, используя ключевое слово this().При выполнении конструктора this() сначала выполняется перегруженный конструктор, который соответствует списку параметров. Затем выполняются операторы, находящиеся внутри исходного конструктора, если таковые существуют. Вызов конструктора this() должен быть первым оператором в конструкторе.

6. Java Development Kit (JDK) —комплект разработчика приложений на языке Java, включающий в себя компилятор Java стандартные библиотеки классов Java, примеры, документацию, различные утилиты и исполнительную систему Java (JRE). В состав JDK не входит интегрированная среда разработки на Java, поэтому разработчик, использующий только JDK, вынужден использовать внешний текстовый редактор и компилировать свои программы, используя утилиты командной строки.
Java Runtime Environment (JRE) — минимальная реализация виртуальной машины, необходимая для исполнения Java-приложений, без компилятора и других средств разработки. Состоит из виртуальной машины —Java Virtual Machine — и библиотеки Java-классов.

7. Да, имеет. Сначала перехватывается FileNotFoundException, так как оно наследуется от IOExceptipon, а затем IOExceptipon. Потому что сначала идет наследующий класс, а потом его «родитель».

8. Внутренние классы – классы, которые размещаются внутри другого класса.
Внутренний класс имеет доступ ко всем переменным и методам своего внешнего класса и может непосредственно ссылаться на них.

9.Суперкласс – главный наследуемый класс.
Подкласс-  наследующий класс.
Подкласс может обратиться к методу или конструктору суперкласса, при помощи конструкции : super. Название метода.

10. Очередь (Queue) – коллекция, в которой элементы чаще всего упорядочиваются по приницпу IFO (first-in-first-out, "первым вошел - первым вышел"). А в стеке реализуется механизм последний вошел - первый вышел" (LIFO).

11. Ситема сборки мусора в Java. В ней более "молодые" объекты, созданные раньше, проверяются сборщиком мусора чаще.

12.Нужно реализовать паттерн Chain of Responsibility (цепочка обязанностей)., т.к. необходимо создать эффективный и компактный механизм обработки событий между двумя классами.
Идея данного паттерна заключается в организации рекуррентного конвейера из обработчиков, в котором каждый обработчик может либо обработать поступившее сообщение (например, только сообщения определенного типа), либо делегировать обработку следующему в конвейере обработчику. Таким образом данный паттерн позволит избежать жесткой зависимости между отправителем и получателем.

13. Модификатор default. Но ключевое слов default писать не надо, считается, что элемент имеет такой модификатор доступа, если не указан никакой другой модификатор доступа.

14. Статический внутренний класс (вложенный) – класс, в котором нет связи между объектом внутреннего класса и объектом внешнего класса. (Объявляется ключевым словом static).
Отличия вложенного класса от внутреннего :
1)	Вложенный класс не может напрямую обратиться к нестатическим членам своего внешнего класса.
2)	Вложенные классы могут содержать статические поля, методы и классы. А внутренние классы могут только наследовать определение статических полей, методов и классов.

15. Статические методы класса  – это такие методы, к которым можно обратиться, не создавая объект данного класса.
Данные методы могут обращаться только к статическим переменным.

16. Существуют следующие типы данных:
 Целочисленные : byte, int,  long, short, cahr
Вещественные: float, double, boolean
Ссылочные : массивы, методы классы.

17. Override – переопределение методов – иная реализации метода в подклассе первоначально определившего метод класса, Выполняется только в том случае если  имена и сигнатуры типов двух методов идентичны. 
Overload – перегрузка методов – случай, когда в классе существуют несколько методов с одинаковым именем и разными параметрами.

18. Итератор – объект, реализующий интерфейс Iterator. Возвращается методом Iterator<E> iterator().
Реализация интерфейса предполагает, что с помощью вызова метода next() можно получить следующий элемент. С помощью метода hasNext() можно узнать, есть ли следующий элемент, и не достигнут ли конец коллекции. И если элементы еще имеются, то hasNext() вернет значение true. Метод hasNext() следует вызывать перед методом next(), так как при достижении конца коллекции метод next() выбрасывает исключение NoSuchElementException. И метод remove() удаляет текущий элемент, который был получен последним вызовом next().

19. Исключениями или исключительными ситуациями (состояниями) называются ошибки, возникшие в программе во время её работы.
Все исключения в Java являются объектами. Поэтому они могут порождаться не только автоматически при возникновении исключительной ситуации, но и создаваться самим разработчиком.
Error - это подкласс, который показывает серьезные проблемы возникающие во время выполнения приложения. Большинство из этих ошибок сигнализируют о ненормальном ходе выполнения программы, т.е. о каких-то критических проблемах. Эти ошибки не рекомендуется отмечать в методах посредством throws-объявления, поэтому они также очень часто называются не проверяемые (unchecked).
 Exception. Эта иерархия также разделяется на две ветви: исключения, производные от класса RuntimeException, и остальные. Исключения типа RuntimeException возникают вследствие ошибок программирования. Все другие исключения являются следствием непредвиденного стечения обстоятельств, например, ошибок ввода-вывода, возникающих при выполнении вполне корректных программ.

20. Оператор throw используется для возбуждения исключения «вруч¬ную». Для того, чтобы сделать это, нужно иметь объект подкласса клас¬са Throwable, который можно либо получить как параметр оператора catch, либо создать с помощью оператора new. А throws используется для задания списка исключений, которые могут возбуждаться методом, но не могут им обрабатываться. Если метод в явном виде (т.е. с помощью оператора throw) возбуждает исключе¬ние соответствующего класса, тип класса исключений должен быть ука¬зан в операторе throws в объявлении этого метода

21. Блок finally нужен для того, чтобы обозначить участок кода, который будет выполняться независимо от того, какие исключения на нем будут возбуждаться или перехватываться. Даже в тех случаях, когда в методе нет соответствующего воз-бужденному исключению раздела catch, блок finally будет выполнен до того, как управление перейдет к операторам, следующим за разделом try. 

Блок finally можно использовать для закрытия файлов или освобождения ресурсов, захваченных для временного использования в начале выполнения метода.

22. Метод finalize() – позволяет определить конкретные действия, выполняемые объектом, перед удалением сборщиком мусора.
Для того, чтобы запустить метод finalize() для объектов, у которых истек срок жизни ( на которых больше нет ссылок), необходимо вызвать метод System.runFinalization().
Лучше не использовать метод finalize() т.к. невозможно предсказать результаты его работы.

23. Статические ( вложенные ) класса.
Внутренние классы
Локальные класса
Анонимные классы
